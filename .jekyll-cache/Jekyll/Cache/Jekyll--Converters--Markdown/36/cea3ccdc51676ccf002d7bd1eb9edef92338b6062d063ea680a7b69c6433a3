I"$<h1 id="dto--objeto-de-transferencia-de-dados">DTO â€“ Objeto de Transferencia de Dados</h1>

<h2 id="ideia-do-post">Ideia do Post</h2>

<p>A idÃ©ia deste post Ã© apresentar o conceito do PadrÃ£o DTO e as conversÃµes que precisam acontecerÂ entre as entidades internas da aplicaÃ§Ã£o e os DTOs externosÂ (objetos de transferÃªncia de dados) publicados de volta para o cliente.</p>

<h2 id="padrÃ£o-de-arquitetura">PadrÃ£o de arquitetura</h2>

<p>O <strong>wikipedia</strong> define padrÃ£o de arquitetura como:
 â€œ<em>â€¦uma soluÃ§Ã£o geral e reutilizÃ¡vel para um problema que ocorre com frequÃªncia emÂ arquitetura de softwareÂ dentro de um determinado contextoâ€¦.</em>â€</p>

<p>Um PadrÃ£o de arquiteturaÂ Ã© uma soluÃ§Ã£o genÃ©rica que pode ser repetida de uma forma geral para um problema comum no design de software.Â Como o prÃ³prio nome sugere, nÃ£o Ã© algo acabado que pode ser transformado diretamente em algum tipo de cÃ³digo.Â Ã‰ um modelo ou uma forma de resolver determinado problema que pode ser usado em vÃ¡rias situaÃ§Ãµes diferentes. 
Nesse post iremos falar um pouco sobre um padrÃ£o de arquitetura bastante importante no desenvolvimento de aplicaÃ§Ãµes.</p>

<h2 id="dto--objeto-de-transferencia-de-dados-1">DTO â€“ Objeto de Transferencia de Dados</h2>

<p>PadrÃ£o <strong>Objeto de TransferÃªncia de Dados</strong>Â (do inglÃªs,Â <strong>Data transfer object</strong> design pattern, ou simplesmenteÂ DTO) Ã© um padrÃ£o de arquitetura de objetos que agregam e encapsulam dados para transferÃªncia.</p>

<p>Diferente dos objetos de negÃ³cioÂ e dosÂ objetos de acesso a dados (DAO), o DTO nÃ£o possui qualquer tipo de comportamento. A sua funÃ§Ã£o Ã©  obter e armazenar dados.
Quando estamos trabalhando com uma interface remota, cada chamada ao servidor pode custar muito tempo de processamento, a depender da quantidade de dados.Â Com o DTO, podemos filtrar quais dados serÃ£o transmitidos e assim reduzir esse problema.</p>

<p>O DTO Ã© bastante usado tambÃ©m quando nÃ£o queremos expor todos os dados da nossa camada de persistÃªncia, mas precisamos exibir ao nosso cliente estes mesmos dados.
Vamos focar nosso post nessa linha de raciocÃ­cio.</p>

<h2 id="entendo-o-contexto-da-aplicaÃ§Ã£o">Entendo o contexto da aplicaÃ§Ã£o</h2>

<p>Utilizaremos como exemplo uma API REST criada com Spring Boot e que possui uma Ã¡rea de cadastro de usuÃ¡rios no sistema.</p>

<p>Essa Ã© a classe que representa os UsuÃ¡rios na nossa API:</p>

<p><img src="/img/posts/2020-08-09-falando-sobre-dto/figura1.jpg" alt="Modelo de Classes" /></p>

<p>A parte em que queremos focar do nosso Controller de UsuÃ¡rios ficou assim:</p>

<p><img src="/img/posts/2020-08-09-falando-sobre-dto/figura2.jpg" alt="Modelo de Classes" /></p>

<p>O mÃ©todo responsÃ¡vel pela criaÃ§Ã£o de um usuÃ¡rio na nossa aplicaÃ§Ã£o espera como parametro um Usuario. Este Usuario serÃ¡ recebido num formato Json no corpo da requisiÃ§Ã£o, passarÃ¡ pela nossa regra de negÃ³cio na camada Service e posteriormente serÃ¡ persistido no banco de dados na nossa camada repository (Esses passos foram abstraÃ­dos no exemplo e nas imagens mas eles estÃ£o lÃ¡).</p>

<p>Aqui jÃ¡ comeÃ§amos a perceber uma falha grave de seguranÃ§a. Analisando nossa classe UsuÃ¡rio, veremos que ela possui um atributo do tipo Booleano, â€œAdminâ€, inicializada com valor â€œfalseâ€.</p>

<p><img src="/img/posts/2020-08-09-falando-sobre-dto/figura3.jpg" alt="Modelo de Classes" /></p>

<p>Logo, caso seja passado o valor true para este parametro na requisiÃ§Ã£o, qualquer um poderÃ¡ se tornar aministrador da nossa aplicaÃ§Ã£o. 
Tornar um usuÃ¡rio administrador nÃ£o deve ser algo acessÃ­vel a qualquer um, exige uma lÃ³gica e um tratamento individual na nossa aplicaÃ§Ã£o, deve seguir regras e nÃ£o ser liberado para qualquer um que tenha acesso ao nosso mÃ©todo salvar().  Sendo assim, o atributo â€œAdminâ€ nÃ£o deve ser recebido por meio deste tipo de requisiÃ§Ã£o.</p>

<p>Se tivessemos uma classe apenas com os atributos essenciais para a criaÃ§Ã£o de um cliente, nÃ£o correrÃ­amos esse tipo de risco. PoderÃ­amos usÃ¡-la para receber os parametros e assim, manipulÃ¡-los da forma que quisermos.</p>

<p>A idÃ©ia do DTO Ã© essa.</p>

<p>Vamos criar uma classe que, seguindo a convenÃ§Ã£o, se chamarÃ¡ UsuarioDTOÂ e vamos dizer que esperamos um objeto desse tipo como parÃ¢metro do mÃ©todoÂ salvar()Â do nossoÂ UsuarioController. 
Nesta classe vamos usar apenas os atributos que de fato devem ser passados pelo Cliente.</p>

<p>A permissÃ£o para transforamar um UsuÃ¡rio em Admin serÃ¡ feito posteriormente numa lÃ³gica seguindo a regra para tal. 
Como anotamos o id da nossa Classe Usuario com @GeneratedValue, ele serÃ¡ gerado automaticamente, nÃ£o sendo assim necessario neste momento.</p>

<p>Dessa forma teremos como atributos da nossa Classe UsuarioDTO apenas nome, email e senha:</p>

<p><img src="/img/posts/2020-08-09-falando-sobre-dto/figura4.jpg" alt="Modelo de Classes" /></p>

<p>Agora sim podemos, em vez de, receber um UsuÃ¡rio com todos os atributos, receber um UsuarioDTO com apenas os atributos necessarios para a criaÃ§Ã£o do UsuÃ¡rio.</p>

<p><img src="/img/posts/2020-08-09-falando-sobre-dto/figura5.jpg" alt="Modelo de Classes" /></p>

<p>SÃ³ que agora temos um novo problema. O mÃ©todo salvar() do nosso UsuarioService, espera um UsuÃ¡rio como parametro, e nÃ£o um UsuarioDTO. Isso Ã© simples de resolver e existem diversas formas de fazer isso. Podemos falar sobre isso num outro post. Neste post aqui nÃ³s iremos fazer a conversÃ£o DTO â€“ Entity utilizando a biblioteca ModelMapper.</p>

<h3 id="doc-modelmapper-httpmodelmapperorgjavadoc">DOC ModelMapper: http://modelmapper.org/javadoc/</h3>

<p>Adicionando Model Mapper ao nosso projeto</p>

<p>Para podermos utilizar o modelMapper em nosso projeto precisamos adcionar sua dependÃªncia no pom.xml:</p>

<p><img src="/img/posts/2020-08-09-falando-sobre-dto/figura6.jpg" alt="Modelo de Classes" /></p>

<p>Ã‰ necessario tambÃ©m definirmos oÂ beanÂ ModelMapperÂ em nossa configuraÃ§Ã£o do Spring:</p>

<p><img src="/img/posts/2020-08-09-falando-sobre-dto/figura7.jpg" alt="Modelo de Classes" /></p>

<h2 id="como-funciona">Como funciona</h2>

<p>O Model Mapper, entre outros, possui um mÃ©todo chamado map(), que espera receber dois parametros. O primeiro seria o objeto que estamos querendo converterÂ eÂ o segundo, a classe destino.
Recebidos, os dois parametrosÂ serÃ£o analisados â€‹â€‹para determinar quais propriedades correspondem implicitamente de acordo com umaÂ estratÃ©gia de correspondÃªnciaÂ e outraÂ configuraÃ§Ã£o.Â Traduzindoâ€¦ serÃ£o checadas quais propriedades o objeto de origem tÃªm em comum com a classe de destino e  mapeando de acordo com essas correspondÃªncias. Dessa forma criaremos um mÃ©todo especÃ­fico para fazer essa conversÃ£o. No nosso exemplo ficarÃ¡ assim:</p>

<p><img src="/img/posts/2020-08-09-falando-sobre-dto/figura10.jpg" alt="Modelo de Classes" /></p>

<p>E nosso salvar() do UsuarioController ficarÃ¡ dessa forma:</p>

<p><img src="/img/posts/2020-08-09-falando-sobre-dto/figura11.jpg" alt="Modelo de Classes" /></p>

<p>PorÃ©m ainda temos um problema. Tanto a classe Usuario, como UsuarioDTO, possuem o atributo senha. Dessa forma ao enviarmos um UsuÃ¡rio ou atÃ© mesmo um UsuarioDTO para o Cliente como resposta a requisiÃ§Ã£o, a senha deste ficarÃ¡ visÃ­vel gerando uma nova falha de seguranÃ§a. Quando enviamos uma resposta, queremos passar um UsuÃ¡rio para o cliente sem informar a senha. Como podemos fazer isso? Ã‰ isso mesmo. Vamos criar um novo DTO e esse serÃ¡ exclusivo para respostas ao cliente. O nome dessa classe serÃ¡ UsuarioRespostaDTO e ficarÃ¡ assim:</p>

<p><img src="/img/posts/2020-08-09-falando-sobre-dto/figura12.jpg" alt="Modelo de Classes" /></p>

<p>Assim como fizemos com o UsuarioDTO , precisaremos agora converter um UsuÃ¡rio em UsuarioRespostaDTO. De forma similar criaremos um mÃ©todo para isso:</p>

<p><img src="/img/posts/2020-08-09-falando-sobre-dto/figura13.jpg" alt="Modelo de Classes" /></p>

<p>Por fim o retorno do nosso mÃ©todo de salvar() do nosso Controller serÃ¡:</p>

<p><img src="/img/posts/2020-08-09-falando-sobre-dto/figura14.jpg" alt="Modelo de Classes" /></p>

<h2 id="conclusÃ£o">ConclusÃ£o</h2>

<p>Este post explicou a idÃ©ia central do padrÃ£o de projeto DTO e tentou mostrar sua utilidade e a forma de manipular os dados recebidos e enviados na comunicaÃ§Ã£o servidor â€“ cliente.
Existem outras formas de fazer a conversÃ£o entidade â€“ DTO. Como a idÃ©ia central era explicar sobre o DTO, esses outras formas nÃ£o foram abordadas nesse post. Deixe seu comentÃ¡rio caso vocÃª queira u post especÃ­fico sobre esse tema.</p>

<h2 id="links-interessantes">Links Interessantes:</h2>
<ul>
  <li><a href="https://www.devmedia.com.br/diferenca-entre-os-patterns-po-pojo-bo-dto-e-vo/28162">Dev Media</a></li>
  <li><a href="http://modelmapper.org/">Model Mapper</a></li>
  <li><a href="https://www.baeldung.com/entity-to-and-from-dto-for-a-java-spring-application">Baeldung</a></li>
</ul>

<h2 id="montival-juniorestudante-desenvolvimento-java">Montival Junior(Estudante Desenvolvimento Java)</h2>

<ul>
  <li><a href="https://github.com/MonthAlcantara">Github:</a></li>
  <li><a href="https://www.linkedin.com/in/montivaljunior">Linkedin:</a></li>
  <li><a href="https://monthalcantara.github.io/">Blog pessoal:</a></li>
</ul>
:ET
I"ÿ$<h1 id="dto--objeto-de-transferencia-de-dados">DTO â€“ Objeto de Transferencia de Dados</h1>

<h2 id="ideia-do-post">Ideia do Post</h2>

<p>A ideia deste post Ã© apresentar o conceito do PadrÃ£o DTO e as conversÃµesÂ entre entidades internas da aplicaÃ§Ã£o e os DTOs externos publicados de volta para o cliente.</p>

<h2 id="padrÃ£o-de-arquitetura">PadrÃ£o de arquitetura</h2>

<p>O <strong>wikipedia</strong> define padrÃ£o de arquitetura como:
 â€œ<em>â€¦uma soluÃ§Ã£o geral e reutilizÃ¡vel para um problema que ocorre com frequÃªncia emÂ arquitetura de softwareÂ dentro de um determinado contextoâ€¦.</em>â€</p>

<p>Um PadrÃ£o de arquiteturaÂ Ã© uma soluÃ§Ã£o genÃ©rica que pode ser repetida de uma forma geral para um problema comum no design de software.Â Como o prÃ³prio nome sugere, nÃ£o Ã© algo acabado que pode ser transformado diretamente em algum tipo de cÃ³digo.Â Ã‰ um modelo ou uma forma de resolver determinado problema que pode ser usado em vÃ¡rias situaÃ§Ãµes diferentes. 
Nesse post iremos falar um pouco sobre um padrÃ£o de arquitetura bastante utilizado no desenvolvimento de aplicaÃ§Ãµes.</p>

<h2 id="dto--objeto-de-transferencia-de-dados-1">DTO â€“ Objeto de Transferencia de Dados</h2>

<p>PadrÃ£o <strong>Objeto de TransferÃªncia de Dados</strong>Â (do inglÃªs,Â <strong>Data transfer object</strong> design pattern, ou simplesmenteÂ DTO) Ã© um padrÃ£o de arquitetura de objetos que agregam e encapsulam dados para transferÃªncia.</p>

<p>Diferente do que ocorre com os objetos de negÃ³cioÂ e osÂ objetos de acesso a dados (DAO), o DTO nÃ£o possui qualquer tipo de comportamento. A sua funÃ§Ã£o Ã© obter e armazenar dados.
Quando estamos trabalhando com uma interface remota, cada chamada ao servidor pode custar muito tempo de processamento, a depender da quantidade de dados.Â Com o DTO, podemos filtrar quais dados serÃ£o transmitidos e assim reduzir esse problema.</p>

<p>O DTO Ã© bastante utilizado tambÃ©m quando nÃ£o queremos expor todos os dados da nossa camada de persistÃªncia mas precisamos exibir ao nosso cliente estes mesmos dados.
Vamos focar nosso post nessa linha de raciocÃ­cio.</p>

<h2 id="entendendo-o-contexto-da-aplicaÃ§Ã£o">Entendendo o contexto da aplicaÃ§Ã£o</h2>

<p>Utilizaremos como exemplo uma API REST criada com Spring Boot e que possui uma Ã¡rea de cadastro de usuÃ¡rios no sistema.</p>

<p>Essa Ã© a classe que representa os usuÃ¡rios na nossa API:</p>

<p><img src="/img/posts/2020-08-09-falando-sobre-dto/figura1.jpg" alt="Modelo de Classes" /></p>

<p>A parte em que queremos focar, do nosso Controller de usuÃ¡rios, ficou assim:</p>

<p><img src="/img/posts/2020-08-09-falando-sobre-dto/figura2.jpg" alt="Modelo de Classes" /></p>

<p>O mÃ©todo responsÃ¡vel pela criaÃ§Ã£o de um usuÃ¡rio na nossa aplicaÃ§Ã£o espera como parÃ¢metro um objeto do tipo Usuario. Este serÃ¡ recebido num formato Json, no corpo da requisiÃ§Ã£o, passarÃ¡ pela nossa regra de negÃ³cio na camada Service e posteriormente serÃ¡ persistido no banco de dados na nossa camada repository (Esses passos foram abstraÃ­dos no exemplo e nas imagens mas eles estÃ£o lÃ¡).</p>

<p>Nesse momento comeÃ§amos a perceber uma falha grave de seguranÃ§a da nossa aplicaÃ§Ã£o. Analisando nossa classe Usuario, veremos que ela possui um atributo do tipo booleano, â€œAdminâ€, inicializada com o valor â€œfalseâ€.</p>

<p><img src="/img/posts/2020-08-09-falando-sobre-dto/figura3.jpg" alt="Modelo de Classes" /></p>

<p>Logo, caso seja passado o valor â€œtrueâ€ para este parÃ¢metro na requisiÃ§Ã£o, qualquer um poderÃ¡ se tornar administrador da nossa aplicaÃ§Ã£o. 
A possibilidade de tornar um usuÃ¡rio em administrador nÃ£o deve ser algo acessÃ­vel a qualquer um. Exige uma lÃ³gica, um tratamento individual na nossa aplicaÃ§Ã£o, seguindo regras que nÃ³s como os desenvolvedores do projeto iremos estabelecer. Sendo assim, o atributo â€œAdminâ€ nÃ£o deve ser considerado como um possÃ­vel parÃ¢metro de entrada a ser recebido por meio deste tipo de requisiÃ§Ã£o.</p>

<p>AliÃ¡s, se tivÃ©ssemos uma classe apenas com os atributos essenciais para a criaÃ§Ã£o de um usuÃ¡rio, nÃ£o correrÃ­amos esse tipo de risco. PoderÃ­amos usÃ¡-la para receber os parÃ¢metros, e assim manipulÃ¡-los da forma que quisermos.</p>

<p>A ideia do DTO Ã© essa.</p>

<p>Vamos criar uma classe que, seguindo a convenÃ§Ã£o, se chamarÃ¡ UsuarioDTOÂ e vamos dizer que esperamos um objeto desse tipo como parÃ¢metro do mÃ©todoÂ salvar()Â do nossoÂ UsuarioController. 
Nesta classe vamos usar apenas os atributos que de fato devem ser passados pelo cliente.</p>

<p>A permissÃ£o para transformar um usuÃ¡rio em Admin serÃ¡ feito posteriormente numa lÃ³gica seguindo a regra para tal. 
Como anotamos o id da nossa classe Usuario com @GeneratedValue, ele serÃ¡ gerado automaticamente, nÃ£o sendo assim necessario neste momento.</p>

<p>Dessa forma teremos como atributos da nossa classe UsuarioDTO apenas nome, email e senha:</p>

<p><img src="/img/posts/2020-08-09-falando-sobre-dto/figura4.jpg" alt="Modelo de Classes" /></p>

<p>Agora sim podemos, em vez de, receber um Usuario com todos os atributos, iremos receber um UsuarioDTO com apenas os atributos necessÃ¡rios para a criaÃ§Ã£o do usuÃ¡rio.</p>

<p><img src="/img/posts/2020-08-09-falando-sobre-dto/figura5.jpg" alt="Modelo de Classes" /></p>

<p>SÃ³ que agora temos um novo problema. O mÃ©todo salvar() do nosso UsuarioService, espera um Usuario como parÃ¢metro, e nÃ£o um UsuarioDTO. Isso Ã© simples de resolver e existem diversas formas de fazer isso. Podemos falar sobre isso num outro post. Neste post aqui nÃ³s iremos fazer a conversÃ£o DTO â€“ Entity utilizando a biblioteca ModelMapper.</p>

<p><a href="http://modelmapper.org/javadoc/">DOC ModelMapper</a></p>

<h2 id="adicionando-o-model-mapper-ao-nosso-projeto">Adicionando o Model Mapper ao nosso projeto</h2>

<p>Para podermos utilizar o modelMapper em nosso projeto precisamos adicionar sua dependÃªncia no pom.xml:</p>

<p><img src="/img/posts/2020-08-09-falando-sobre-dto/figura6.jpg" alt="Modelo de Classes" /></p>

<p>Ã‰ necessÃ¡rio tambÃ©m definirmos oÂ beanÂ ModelMapperÂ em nossa configuraÃ§Ã£o do Spring:</p>

<p><img src="/img/posts/2020-08-09-falando-sobre-dto/figura7.jpg" alt="Modelo de Classes" /></p>

<h2 id="como-funciona">Como funciona</h2>

<p>O Model Mapper, entre outros, possui um mÃ©todo chamado map(), que espera receber dois parÃ¢metros. O primeiro seria o objeto que estamos querendo converterÂ eÂ o segundo, a classe destino.
Recebidos os dois parÃ¢metros, estesÂ serÃ£o analisados â€‹â€‹para determinar quais propriedades correspondem implicitamente de acordo com umaÂ estratÃ©gia de correspondÃªnciaÂ e outraÂ configuraÃ§Ã£o.Â Traduzindoâ€¦ serÃ£o checadas quais propriedades o objeto de origem tÃªm em comum com a classe de destino, mapeando de acordo com essas correspondÃªncias. Dessa forma criaremos um mÃ©todo especÃ­fico para fazer essa conversÃ£o. No nosso exemplo ficarÃ¡ assim:</p>

<p><img src="/img/posts/2020-08-09-falando-sobre-dto/figura10.jpg" alt="Modelo de Classes" /></p>

<p>E nosso salvar() do UsuarioController ficarÃ¡ dessa forma:</p>

<p><img src="/img/posts/2020-08-09-falando-sobre-dto/figura11.jpg" alt="Modelo de Classes" /></p>

<p>PorÃ©m ainda temos um problema. Tanto a classe Usuario, como UsuarioDTO, possuem o atributo senha. Dessa forma ao enviarmos um Usuario ou atÃ© mesmo um UsuarioDTO para o Cliente como resposta a requisiÃ§Ã£o, a senha deste ficarÃ¡ visÃ­vel gerando uma nova falha de seguranÃ§a. Quando enviamos uma resposta, queremos passar as informaÃ§Ãµes do usuÃ¡rio para o cliente sem informar a senha. Como podemos fazer isso? Ã‰ isso mesmo. Vamos criar um novo DTO e esse serÃ¡ exclusivo para respostas ao cliente. O nome dessa classe serÃ¡ UsuarioRespostaDTO e ficarÃ¡ assim:</p>

<p><img src="/img/posts/2020-08-09-falando-sobre-dto/figura12.jpg" alt="Modelo de Classes" /></p>

<p>Assim como fizemos com o UsuarioDTO, precisaremos agora converter um Usuario em UsuarioRespostaDTO. De forma similar criaremos um mÃ©todo para isso:</p>

<p><img src="/img/posts/2020-08-09-falando-sobre-dto/figura13.jpg" alt="Modelo de Classes" /></p>

<p>Por fim o retorno do mÃ©todo salvar() do nosso Controller serÃ¡:</p>

<p><img src="/img/posts/2020-08-09-falando-sobre-dto/figura14.jpg" alt="Modelo de Classes" /></p>

<h2 id="conclusÃ£o">ConclusÃ£o</h2>

<p>Este post tentou explicar a ideia central do padrÃ£o de projeto DTO, mostrar sua utilidade e a forma de manipular os dados recebidos e enviados na comunicaÃ§Ã£o servidor â€“ cliente.
Existem outras formas de fazer as conversÃµes entre entidade â€“ DTO. Essas outras formas nÃ£o foram abordadas nesse post mas podemos falar delas posteriormente. Deixe seu comentÃ¡rio caso vocÃª queira um post especÃ­fico sobre esse tema.</p>

<h2 id="links-interessantes">Links Interessantes:</h2>
<ul>
  <li><a href="https://www.devmedia.com.br/diferenca-entre-os-patterns-po-pojo-bo-dto-e-vo/28162">Dev Media</a></li>
  <li><a href="http://modelmapper.org/">Model Mapper</a></li>
  <li><a href="https://www.baeldung.com/entity-to-and-from-dto-for-a-java-spring-application">Baeldung</a></li>
</ul>

<h2 id="montival-junior-estudante-de-desenvolvimento-java">Montival Junior (Estudante de Desenvolvimento Java)</h2>

<ul>
  <li><a href="https://github.com/MonthAlcantara">Github</a></li>
  <li><a href="https://www.linkedin.com/in/montivaljunior">Linkedin</a></li>
  <li><a href="https://monthalcantara.github.io/">Blog pessoal</a></li>
</ul>
:ET